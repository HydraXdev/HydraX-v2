#!/usr/bin/env python3
"""
Black Box Signal Interceptor - Logs EVERY VENOM signal
Intercepts signals right after generation, before mission building
This is the ONLY source of truth for signal quality and volume
"""

# ┌──────────────────────────────────────────────────────────────┐
# │ BLACK BOX TRUTH SYSTEM - PRIMARY SIGNAL INTERCEPTOR          │
# │ Logs EVERY signal generated by VENOM, executed or not        │
# │ This is the ONLY source of ground truth in BITTEN           │
# │ Used for XP scoring, performance reporting, post-mortem      │
# └──────────────────────────────────────────────────────────────┘

import json
import time
import logging
from datetime import datetime
from pathlib import Path
from typing import Dict, Optional
import threading
import requests
from dataclasses import dataclass, asdict

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('BlackBoxInterceptor')

@dataclass
class SignalRecord:
    """Complete signal record at generation time"""
    # Signal identification
    signal_id: str
    timestamp: str
    
    # Signal details
    symbol: str
    direction: str
    signal_type: str  # RAPID_ASSAULT/PRECISION_STRIKE
    
    # Quality scores
    tcs_score: float
    confidence: float
    venom_version: str = "v7.0"
    
    # Entry/exit levels
    entry_price: float
    stop_loss: float
    take_profit: float
    target_pips: float
    stop_pips: float
    risk_reward: float
    
    # Market conditions at generation
    spread: float = 0
    market_volatility: str = "normal"
    session: str = "unknown"
    
    # Execution tracking
    sent_to_users: bool = False
    user_count: int = 0
    fired_count: int = 0
    
    # Outcome tracking (updated later)
    outcome: Optional[str] = None  # WIN/LOSS/EXPIRED/CANCELLED
    outcome_timestamp: Optional[str] = None
    execution_price: Optional[float] = None
    max_adverse_excursion: Optional[float] = None
    max_favorable_excursion: Optional[float] = None
    
    def to_jsonl(self) -> str:
        """Convert to JSONL format for truth log"""
        return json.dumps(asdict(self))

class BlackBoxSignalInterceptor:
    """
    Primary signal interceptor - logs EVERY signal at generation
    This runs between VENOM and mission builder
    """
    
    def __init__(self):
        self.truth_log = Path("/root/HydraX-v2/truth_log.jsonl")
        self.signal_count = 0
        self.session_start = datetime.utcnow()
        self.lock = threading.Lock()
        
        # Signal quality tracking
        self.quality_stats = {
            'total_signals': 0,
            'high_confidence': 0,  # 85%+
            'medium_confidence': 0,  # 75-85%
            'low_confidence': 0,  # <75%
            'by_type': {
                'RAPID_ASSAULT': 0,
                'PRECISION_STRIKE': 0
            },
            'by_symbol': {}
        }
        
        logger.info("🔒 Black Box Signal Interceptor initialized")
        logger.info("📜 Truth log: /root/HydraX-v2/truth_log.jsonl")
        logger.info("🎯 Intercepting ALL VENOM signals at generation")
        
    def intercept_signal(self, signal_data: Dict) -> Dict:
        """
        Intercept and log signal RIGHT AFTER VENOM generation
        This is called BEFORE mission builder or user distribution
        
        Returns: The same signal data (pass-through)
        """
        try:
            # Create signal record
            record = SignalRecord(
                signal_id=signal_data.get('signal_id', f"UNKNOWN_{int(time.time() * 1000)}"),
                timestamp=datetime.utcnow().isoformat(),
                
                # Core signal data
                symbol=signal_data.get('symbol', 'UNKNOWN'),
                direction=signal_data.get('direction', 'UNKNOWN'),
                signal_type=signal_data.get('signal_type', 'UNKNOWN'),
                
                # Quality metrics
                tcs_score=signal_data.get('tcs_score', 0),
                confidence=signal_data.get('confidence', 0),
                
                # Price levels
                entry_price=signal_data.get('entry', 0),
                stop_loss=signal_data.get('sl', 0),
                take_profit=signal_data.get('tp', 0),
                target_pips=signal_data.get('target_pips', 0),
                stop_pips=signal_data.get('stop_pips', 0),
                risk_reward=signal_data.get('risk_reward', 0),
                
                # Market conditions
                spread=signal_data.get('spread', 0),
                market_volatility=signal_data.get('volatility', 'normal'),
                session=signal_data.get('session', 'unknown')
            )
            
            # Log to truth file immediately
            self._write_signal_record(record)
            
            # Update statistics
            self._update_statistics(record)
            
            # Log summary
            logger.info(f"📡 Signal intercepted: {record.signal_id}")
            logger.info(f"   {record.symbol} {record.direction} - {record.signal_type}")
            logger.info(f"   TCS: {record.tcs_score}% | Confidence: {record.confidence}%")
            logger.info(f"   Total signals today: {self.signal_count}")
            
        except Exception as e:
            logger.error(f"Failed to intercept signal: {e}")
            
        # ALWAYS pass through the signal unchanged
        return signal_data
        
    def _write_signal_record(self, record: SignalRecord):
        """Write signal record to append-only truth log"""
        try:
            with self.lock:
                with open(self.truth_log, 'a') as f:
                    f.write(record.to_jsonl() + '\n')
                self.signal_count += 1
                
            logger.debug(f"✅ Signal logged to truth file: {record.signal_id}")
            
        except Exception as e:
            logger.error(f"CRITICAL: Failed to write signal to truth log: {e}")
            
    def _update_statistics(self, record: SignalRecord):
        """Update running statistics"""
        with self.lock:
            self.quality_stats['total_signals'] += 1
            
            # Confidence buckets
            if record.confidence >= 85:
                self.quality_stats['high_confidence'] += 1
            elif record.confidence >= 75:
                self.quality_stats['medium_confidence'] += 1
            else:
                self.quality_stats['low_confidence'] += 1
                
            # By type
            signal_type = record.signal_type
            if signal_type in self.quality_stats['by_type']:
                self.quality_stats['by_type'][signal_type] += 1
                
            # By symbol
            symbol = record.symbol
            if symbol not in self.quality_stats['by_symbol']:
                self.quality_stats['by_symbol'][symbol] = 0
            self.quality_stats['by_symbol'][symbol] += 1
            
    def update_signal_outcome(self, signal_id: str, outcome: str, details: Dict = None):
        """
        Update a signal's outcome after completion
        Called when trade hits SL/TP or expires
        """
        # This would update the existing record with outcome data
        # For now, append an outcome record
        outcome_record = {
            'type': 'outcome',
            'signal_id': signal_id,
            'outcome': outcome,
            'timestamp': datetime.utcnow().isoformat(),
            'details': details or {}
        }
        
        try:
            with open(self.truth_log, 'a') as f:
                f.write(json.dumps(outcome_record) + '\n')
                
            logger.info(f"📊 Outcome recorded: {signal_id} - {outcome}")
            
        except Exception as e:
            logger.error(f"Failed to record outcome: {e}")
            
    def get_session_stats(self) -> Dict:
        """Get statistics for current session"""
        runtime = (datetime.utcnow() - self.session_start).total_seconds()
        hours = runtime / 3600
        
        stats = {
            'session_start': self.session_start.isoformat(),
            'runtime_hours': round(hours, 2),
            'total_signals': self.signal_count,
            'signals_per_hour': round(self.signal_count / hours, 1) if hours > 0 else 0,
            'quality_breakdown': self.quality_stats
        }
        
        return stats
        
    def get_signal_history(self, hours: int = 24) -> list:
        """Get signal history for analysis"""
        signals = []
        cutoff = datetime.utcnow() - timedelta(hours=hours)
        
        if self.truth_log.exists():
            with open(self.truth_log, 'r') as f:
                for line in f:
                    try:
                        record = json.loads(line.strip())
                        if record.get('type') != 'outcome':  # Skip outcome records
                            timestamp = datetime.fromisoformat(record['timestamp'].replace('Z', '+00:00'))
                            if timestamp > cutoff:
                                signals.append(record)
                    except:
                        pass
                        
        return signals

# Global interceptor instance
_interceptor = None

def get_black_box_interceptor() -> BlackBoxSignalInterceptor:
    """Get or create singleton interceptor"""
    global _interceptor
    if not _interceptor:
        _interceptor = BlackBoxSignalInterceptor()
    return _interceptor

def intercept_venom_signal(signal_data: Dict) -> Dict:
    """
    Main interception point - call this RIGHT AFTER VENOM generates a signal
    BEFORE sending to mission builder or users
    
    Example integration in webapp_server_optimized.py:
    
    @app.route('/api/signals', methods=['POST'])
    def receive_signal():
        signal_data = request.json
        
        # INTERCEPT HERE - Log to Black Box
        from black_box_signal_interceptor import intercept_venom_signal
        signal_data = intercept_venom_signal(signal_data)
        
        # Then continue with normal processing...
        process_signal(signal_data)
    """
    interceptor = get_black_box_interceptor()
    return interceptor.intercept_signal(signal_data)

if __name__ == "__main__":
    # Test the interceptor
    interceptor = get_black_box_interceptor()
    
    print("🔒 Black Box Signal Interceptor - TEST MODE")
    print("=" * 60)
    
    # Simulate a VENOM signal
    test_signal = {
        "signal_id": "VENOM_TEST_" + str(int(time.time() * 1000)),
        "symbol": "EURUSD",
        "direction": "BUY",
        "signal_type": "RAPID_ASSAULT",
        "tcs_score": 87.5,
        "confidence": 92.0,
        "entry": 1.0850,
        "sl": 1.0800,
        "tp": 1.0950,
        "target_pips": 100,
        "stop_pips": 50,
        "risk_reward": 2.0,
        "spread": 1.2,
        "session": "LONDON"
    }
    
    # Intercept it
    result = intercept_venom_signal(test_signal)
    
    # Show stats
    stats = interceptor.get_session_stats()
    print(f"\n📊 Session Statistics:")
    print(f"   Total Signals: {stats['total_signals']}")
    print(f"   High Confidence: {stats['quality_breakdown']['high_confidence']}")
    print(f"   By Type: {stats['quality_breakdown']['by_type']}")
    
    print("\n✅ Test complete - Check truth_log.jsonl")