"""
System Monitoring for BITTEN
Proactive monitoring to prevent issues before they become errors
"""

import psutil
import sqlite3
import requests
import time
import os
import json
import threading
import logging
from datetime import datetime, timedelta
from typing import Dict, Any, List, Optional, Callable
from dataclasses import dataclass, asdict
from enum import Enum
import subprocess
from collections import deque, defaultdict

logger = logging.getLogger("bitten_monitor")

class AlertLevel(Enum):
    """Alert severity levels"""
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"
    EMERGENCY = "emergency"

@dataclass
class MonitoringAlert:
    """Alert generated by monitoring system"""
    timestamp: datetime
    level: AlertLevel
    category: str
    metric: str
    value: float
    threshold: float
    message: str
    resolved: bool = False
    resolution_time: Optional[datetime] = None

class MetricCollector:
    """Collects various system metrics"""
    
    def __init__(self):
        self.metrics_history = defaultdict(lambda: deque(maxlen=100))
        self._lock = threading.Lock()
    
    def collect_system_metrics(self) -> Dict[str, float]:
        """Collect basic system metrics"""
        try:
            # CPU usage
            cpu_percent = psutil.cpu_percent(interval=1)
            
            # Memory usage
            memory = psutil.virtual_memory()
            memory_percent = memory.percent
            
            # Disk usage
            disk = psutil.disk_usage('/')
            disk_percent = (disk.used / disk.total) * 100
            
            # Network I/O
            network = psutil.net_io_counters()
            
            # Process count
            process_count = len(psutil.pids())
            
            # Load average (Linux only)
            load_avg = os.getloadavg()[0] if hasattr(os, 'getloadavg') else 0
            
            metrics = {
                'cpu_percent': cpu_percent,
                'memory_percent': memory_percent,
                'disk_percent': disk_percent,
                'network_bytes_sent': network.bytes_sent,
                'network_bytes_recv': network.bytes_recv,
                'process_count': process_count,
                'load_average': load_avg,
                'timestamp': time.time()
            }
            
            # Store in history
            with self._lock:
                for key, value in metrics.items():
                    if key != 'timestamp':
                        self.metrics_history[key].append((time.time(), value))
            
            return metrics
        
        except Exception as e:
            logger.error(f"Failed to collect system metrics: {e}")
            return {}
    
    def collect_application_metrics(self) -> Dict[str, Any]:
        """Collect BITTEN-specific application metrics"""
        metrics = {}
        
        try:
            # Check if webapp is running
            webapp_running = self._is_process_running("webapp_server.py")
            metrics['webapp_running'] = webapp_running
            
            # Check webapp response time
            if webapp_running:
                response_time = self._test_webapp_response()
                metrics['webapp_response_time'] = response_time
            
            # Check database accessibility
            db_accessible = self._test_database_access()
            metrics['database_accessible'] = db_accessible
            
            # Check Telegram API
            telegram_api_ok = self._test_telegram_api()
            metrics['telegram_api_ok'] = telegram_api_ok
            
            # Check log file sizes
            log_sizes = self._get_log_file_sizes()
            metrics.update(log_sizes)
            
            # Check recent error rates
            error_rates = self._get_recent_error_rates()
            metrics.update(error_rates)
            
        except Exception as e:
            logger.error(f"Failed to collect application metrics: {e}")
        
        return metrics
    
    def _is_process_running(self, process_name: str) -> bool:
        """Check if a process is running"""
        try:
            for proc in psutil.process_iter(['name', 'cmdline']):
                cmdline = proc.info['cmdline'] or []
                if any(process_name in cmd for cmd in cmdline):
                    return True
            return False
        except:
            return False
    
    def _test_webapp_response(self) -> float:
        """Test webapp response time"""
        try:
            start_time = time.time()
            response = requests.get("http://localhost:8888/health", timeout=5)
            response_time = time.time() - start_time
            
            if response.status_code in [200, 503]:
                return response_time
            return -1  # Error indicator
        except:
            return -1
    
    def _test_database_access(self) -> bool:
        """Test database accessibility"""
        db_paths = [
            "data/engagement.db",
            "data/battle_pass.db",
            "data/error_tracking.db"
        ]
        
        for db_path in db_paths:
            if os.path.exists(db_path):
                try:
                    conn = sqlite3.connect(db_path, timeout=2)
                    conn.execute("SELECT 1")
                    conn.close()
                except:
                    return False
        
        return True
    
    def _test_telegram_api(self) -> bool:
        """Test Telegram API connectivity"""
        try:
            # This would use actual bot token in production
            # For now, just test general Telegram API
            response = requests.get("https://api.telegram.org", timeout=5)
            return response.status_code == 200
        except:
            return False
    
    def _get_log_file_sizes(self) -> Dict[str, int]:
        """Get log file sizes"""
        log_dir = "logs"
        log_sizes = {}
        
        if os.path.exists(log_dir):
            for file in os.listdir(log_dir):
                if file.endswith('.log'):
                    file_path = os.path.join(log_dir, file)
                    try:
                        size = os.path.getsize(file_path)
                        log_sizes[f'log_size_{file.replace(".", "_")}'] = size
                    except:
                        continue
        
        return log_sizes
    
    def _get_recent_error_rates(self) -> Dict[str, float]:
        """Get recent error rates from error tracking database"""
        error_rates = {}
        
        try:
            if os.path.exists("data/error_tracking.db"):
                conn = sqlite3.connect("data/error_tracking.db")
                cursor = conn.cursor()
                
                # Errors in last hour
                hour_ago = datetime.now() - timedelta(hours=1)
                cursor.execute(
                    "SELECT COUNT(*) FROM error_events WHERE timestamp > ?",
                    (hour_ago,)
                )
                errors_last_hour = cursor.fetchone()[0]
                error_rates['errors_per_hour'] = errors_last_hour
                
                # Critical errors in last 24 hours
                day_ago = datetime.now() - timedelta(hours=24)
                cursor.execute(
                    "SELECT COUNT(*) FROM error_events WHERE timestamp > ? AND severity = 'critical'",
                    (day_ago,)
                )
                critical_errors = cursor.fetchone()[0]
                error_rates['critical_errors_per_day'] = critical_errors
                
                conn.close()
        
        except Exception as e:
            logger.error(f"Failed to get error rates: {e}")
        
        return error_rates
    
    def get_metric_trend(self, metric_name: str, minutes: int = 30) -> List[tuple]:
        """Get metric trend over specified time period"""
        with self._lock:
            if metric_name not in self.metrics_history:
                return []
            
            cutoff_time = time.time() - (minutes * 60)
            return [
                (timestamp, value) 
                for timestamp, value in self.metrics_history[metric_name]
                if timestamp > cutoff_time
            ]

class AlertManager:
    """Manages monitoring alerts and notifications"""
    
    def __init__(self):
        self.thresholds = self._load_default_thresholds()
        self.active_alerts = {}
        self.alert_history = deque(maxlen=1000)
        self._lock = threading.Lock()
        self.notification_handlers = []
    
    def _load_default_thresholds(self) -> Dict[str, Dict[str, float]]:
        """Load default monitoring thresholds"""
        return {
            'cpu_percent': {
                'warning': 80.0,
                'critical': 95.0
            },
            'memory_percent': {
                'warning': 85.0,
                'critical': 95.0
            },
            'disk_percent': {
                'warning': 85.0,
                'critical': 95.0
            },
            'webapp_response_time': {
                'warning': 2.0,
                'critical': 5.0
            },
            'errors_per_hour': {
                'warning': 10.0,
                'critical': 25.0
            },
            'critical_errors_per_day': {
                'warning': 1.0,
                'critical': 5.0
            },
            'load_average': {
                'warning': 2.0,
                'critical': 4.0
            }
        }
    
    def check_metrics(self, metrics: Dict[str, Any]) -> List[MonitoringAlert]:
        """Check metrics against thresholds and generate alerts"""
        alerts = []
        
        for metric_name, value in metrics.items():
            if metric_name in self.thresholds and isinstance(value, (int, float)):
                alert = self._check_threshold(metric_name, value)
                if alert:
                    alerts.append(alert)
        
        # Process alerts
        for alert in alerts:
            self._process_alert(alert)
        
        return alerts
    
    def _check_threshold(self, metric_name: str, value: float) -> Optional[MonitoringAlert]:
        """Check if a metric value exceeds thresholds"""
        thresholds = self.thresholds[metric_name]
        
        # Determine alert level
        alert_level = None
        threshold_value = None
        
        if value >= thresholds.get('critical', float('inf')):
            alert_level = AlertLevel.CRITICAL
            threshold_value = thresholds['critical']
        elif value >= thresholds.get('warning', float('inf')):
            alert_level = AlertLevel.WARNING
            threshold_value = thresholds['warning']
        
        if alert_level:
            # Check if we already have an active alert for this metric
            alert_key = f"{metric_name}_{alert_level.value}"
            
            with self._lock:
                if alert_key not in self.active_alerts:
                    alert = MonitoringAlert(
                        timestamp=datetime.now(),
                        level=alert_level,
                        category="system",
                        metric=metric_name,
                        value=value,
                        threshold=threshold_value,
                        message=self._generate_alert_message(metric_name, value, threshold_value, alert_level)
                    )
                    
                    self.active_alerts[alert_key] = alert
                    return alert
        
        else:
            # Check if we need to resolve any existing alerts
            self._resolve_alerts_for_metric(metric_name)
        
        return None
    
    def _generate_alert_message(self, metric: str, value: float, threshold: float, level: AlertLevel) -> str:
        """Generate human-readable alert message"""
        metric_descriptions = {
            'cpu_percent': f'CPU usage at {value:.1f}% (threshold: {threshold:.1f}%)',
            'memory_percent': f'Memory usage at {value:.1f}% (threshold: {threshold:.1f}%)',
            'disk_percent': f'Disk usage at {value:.1f}% (threshold: {threshold:.1f}%)',
            'webapp_response_time': f'Webapp response time {value:.2f}s (threshold: {threshold:.1f}s)',
            'errors_per_hour': f'Error rate at {value} errors/hour (threshold: {threshold})',
            'critical_errors_per_day': f'Critical errors at {value} per day (threshold: {threshold})',
            'load_average': f'Load average at {value:.2f} (threshold: {threshold:.1f})'
        }
        
        description = metric_descriptions.get(metric, f'{metric}: {value} (threshold: {threshold})')
        
        level_prefixes = {
            AlertLevel.WARNING: "⚠️ WARNING",
            AlertLevel.CRITICAL: "🚨 CRITICAL",
            AlertLevel.EMERGENCY: "🔥 EMERGENCY"
        }
        
        prefix = level_prefixes.get(level, "ℹ️ INFO")
        
        return f"{prefix}: {description}"
    
    def _process_alert(self, alert: MonitoringAlert):
        """Process a new alert"""
        # Add to history
        with self._lock:
            self.alert_history.append(alert)
        
        # Log the alert
        logger.log(
            logging.CRITICAL if alert.level == AlertLevel.CRITICAL else logging.WARNING,
            alert.message
        )
        
        # Send notifications
        for handler in self.notification_handlers:
            try:
                handler(alert)
            except Exception as e:
                logger.error(f"Notification handler failed: {e}")
    
    def _resolve_alerts_for_metric(self, metric_name: str):
        """Resolve alerts for a metric that's now within normal range"""
        with self._lock:
            to_resolve = [
                key for key in self.active_alerts.keys()
                if key.startswith(f"{metric_name}_")
            ]
            
            for key in to_resolve:
                alert = self.active_alerts[key]
                alert.resolved = True
                alert.resolution_time = datetime.now()
                
                logger.info(f"Alert resolved: {alert.message}")
                del self.active_alerts[key]
    
    def add_notification_handler(self, handler: Callable[[MonitoringAlert], None]):
        """Add a notification handler"""
        self.notification_handlers.append(handler)
    
    def get_active_alerts(self) -> List[MonitoringAlert]:
        """Get currently active alerts"""
        with self._lock:
            return list(self.active_alerts.values())
    
    def get_alert_summary(self, hours: int = 24) -> Dict[str, Any]:
        """Get alert summary for specified time period"""
        cutoff_time = datetime.now() - timedelta(hours=hours)
        
        relevant_alerts = [
            alert for alert in self.alert_history
            if alert.timestamp > cutoff_time
        ]
        
        by_level = defaultdict(int)
        by_category = defaultdict(int)
        
        for alert in relevant_alerts:
            by_level[alert.level.value] += 1
            by_category[alert.category] += 1
        
        return {
            'total_alerts': len(relevant_alerts),
            'active_alerts': len(self.active_alerts),
            'by_level': dict(by_level),
            'by_category': dict(by_category),
            'time_period_hours': hours
        }

class SystemMonitor:
    """Main system monitoring class"""
    
    def __init__(self, check_interval: int = 60):
        self.check_interval = check_interval
        self.metric_collector = MetricCollector()
        self.alert_manager = AlertManager()
        self.running = False
        self.monitor_thread = None
        
        # Setup notification handlers
        self._setup_notification_handlers()
    
    def _setup_notification_handlers(self):
        """Setup default notification handlers"""
        def log_alert(alert: MonitoringAlert):
            """Log alert to file"""
            alert_log_path = "logs/alerts.log"
            os.makedirs(os.path.dirname(alert_log_path), exist_ok=True)
            
            with open(alert_log_path, "a") as f:
                f.write(f"{alert.timestamp.isoformat()} - {alert.message}\n")
        
        self.alert_manager.add_notification_handler(log_alert)
    
    def start_monitoring(self):
        """Start the monitoring system - EMERGENCY DISABLED"""
        if self.running:
            return
        
        self.running = False  # EMERGENCY: Disabled to prevent auto-restart
        # self.monitor_thread = threading.Thread(target=self._monitoring_loop, daemon=True)
        # self.monitor_thread.start()
        
        logger.info("EMERGENCY: System monitoring DISABLED")
    
    def stop_monitoring(self):
        """Stop the monitoring system"""
        self.running = False
        if self.monitor_thread:
            self.monitor_thread.join(timeout=10)
        
        logger.info("System monitoring stopped")
    
    def _monitoring_loop(self):
        """Main monitoring loop"""
        while self.running:
            try:
                # Collect metrics
                system_metrics = self.metric_collector.collect_system_metrics()
                app_metrics = self.metric_collector.collect_application_metrics()
                
                all_metrics = {**system_metrics, **app_metrics}
                
                # Check for alerts
                alerts = self.alert_manager.check_metrics(all_metrics)
                
                # Log metrics periodically
                if int(time.time()) % 300 == 0:  # Every 5 minutes
                    logger.info(f"System metrics: CPU {system_metrics.get('cpu_percent', 0):.1f}%, "
                              f"Memory {system_metrics.get('memory_percent', 0):.1f}%, "
                              f"Disk {system_metrics.get('disk_percent', 0):.1f}%")
                
                time.sleep(self.check_interval)
            
            except Exception as e:
                logger.error(f"Monitoring loop error: {e}")
                time.sleep(self.check_interval)
    
    def get_system_status(self) -> Dict[str, Any]:
        """Get comprehensive system status"""
        # Collect current metrics
        system_metrics = self.metric_collector.collect_system_metrics()
        app_metrics = self.metric_collector.collect_application_metrics()
        
        # Get alert summary
        alert_summary = self.alert_manager.get_alert_summary()
        
        # Determine overall health
        active_critical = len([
            alert for alert in self.alert_manager.get_active_alerts()
            if alert.level == AlertLevel.CRITICAL
        ])
        
        if active_critical > 0:
            overall_status = "critical"
        elif alert_summary['active_alerts'] > 0:
            overall_status = "warning"
        else:
            overall_status = "healthy"
        
        return {
            'overall_status': overall_status,
            'timestamp': datetime.now().isoformat(),
            'system_metrics': system_metrics,
            'application_metrics': app_metrics,
            'alert_summary': alert_summary,
            'active_alerts': [asdict(alert) for alert in self.alert_manager.get_active_alerts()],
            'monitoring_active': self.running
        }
    
    def force_check(self) -> Dict[str, Any]:
        """Force an immediate monitoring check"""
        system_metrics = self.metric_collector.collect_system_metrics()
        app_metrics = self.metric_collector.collect_application_metrics()
        all_metrics = {**system_metrics, **app_metrics}
        
        alerts = self.alert_manager.check_metrics(all_metrics)
        
        return {
            'metrics_collected': len(all_metrics),
            'new_alerts': len(alerts),
            'metrics': all_metrics,
            'alerts': [asdict(alert) for alert in alerts]
        }

# Global monitor instance
system_monitor = SystemMonitor()

def start_system_monitoring():
    """Start system monitoring"""
    system_monitor.start_monitoring()

def stop_system_monitoring():
    """Stop system monitoring"""
    system_monitor.stop_monitoring()

def get_monitoring_status() -> Dict[str, Any]:
    """Get current monitoring status"""
    return system_monitor.get_system_status()

def force_monitoring_check() -> Dict[str, Any]:
    """Force immediate monitoring check"""
    return system_monitor.force_check()

if __name__ == "__main__":
    # Test the monitoring system
    print("Starting monitoring system test...")
    
    monitor = SystemMonitor(check_interval=5)  # 5 second interval for testing
    monitor.start_monitoring()
    
    try:
        # Let it run for 30 seconds
        time.sleep(30)
        
        # Get status
        status = monitor.get_system_status()
        print("System Status:")
        print(json.dumps(status, indent=2, default=str))
        
    finally:
        monitor.stop_monitoring()
        print("Monitoring test completed.")